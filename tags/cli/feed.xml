<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CLI on tellme.tokyo</title>
    <link>https://tellme.tokyo/tags/cli/</link>
    <description>Recent content in CLI on tellme.tokyo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>BABAROT All Right Reserved.</copyright>
    <lastBuildDate>Wed, 02 Mar 2022 20:35:20 +0900</lastBuildDate><atom:link href="https://tellme.tokyo/tags/cli/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>新しいコマンドラインツール向けのパッケージマネージャ</title>
      <link>https://tellme.tokyo/post/2022/03/02/package-manager-for-cli/</link>
      <pubDate>Wed, 02 Mar 2022 20:35:20 +0900</pubDate>
      
      <guid>https://tellme.tokyo/post/2022/03/02/package-manager-for-cli/</guid>
      <description>最近、afx という CLI 向けのパッケージマネージャを公開した。ここで &amp;ldquo;CLI のパッケージ&amp;rdquo; とは例えば jq のようなコマンドラインツールや zsh-history-substring-search のようなヒストリ補完をするシェルのプラグインを指す (bash/zsh/fish)。afx ではこれらを 1 つのツールで管理すること、コードで表現して管理することを目的としている。コードには YAML を使用する。
また afx では、管理するパッケージとそのツールの設定を一緒に保つことができる。例えば jq 自体の管理とその jq で使う環境変数やエイリアスの設定などを同じ YAML ファイルに記述できる。これによって、各種ツールの設定が bashrc/zshrc などに散乱することや、もう使っていないなどの理由でツール自体はインストールされていないのに設定だけが残っている、みたいなことを防ぐことができる。
# ~/.config/afx/commands.yamlgithub:- name:stedolan/jqdescription:Command-line JSON processorowner:stedolanrepo:jqrelease:name:jqtag:jq-1.6command:link:- from:&amp;#39;*jq*&amp;#39;to:jqalias:jq:jq -Csnippet:|# you can write shell script here # -&amp;gt; define global alias (zsh feature) if [[ $SHELL == *zsh* ]]; then alias -g J=&amp;#39;| jq -C . | less -F&amp;#39; fi# ~/.config/afx/plugins.yamlgithub:- name:b4b4r07/enhancddescription:A next-generation cd command with your interactive filterowner:b4b4r07repo:enhancdplugin:env:ENHANCD_FILTER:fzf --height 25% --reverse --ansi:fzy:pecosources:- init.</description>
    </item>
    
    <item>
      <title>Go で書いた CLI ツールのリリースは GoReleaser と GitHub Actions で個人的には決まり</title>
      <link>https://tellme.tokyo/post/2020/02/04/release-go-cli-tool/</link>
      <pubDate>Tue, 04 Feb 2020 00:32:10 +0900</pubDate>
      
      <guid>https://tellme.tokyo/post/2020/02/04/release-go-cli-tool/</guid>
      <description>lt;dr GoReleaser と GitHub Actions を使うと簡単にビルドしたバイナリを作ってアップロードできる。
 2つの YAML を書いてリポジトリにコミットする  .github/workflows/release.yml .goreleaser.yml   git tag して push する バイナリがリリースされる  専用のツールをローカルにインストールする必要はない。
本題 前に、Go のコマンドラインツールを簡単にリリースする | tellme.tokyo というブログを書いた。
それよりももっと楽になったので紹介する。
基本的にこのページで紹介する方法では 2 つの YAML をリポジトリに置くだけで終わる。 ローカルに何かをインストールする必要もない。 2 つの YAML を書くだけ (コピペするだけ) でリリースの準備が整う。
まずはじめに .github/workflows/release.yml を置く。 編集不要でコピペする。
name:releaseon:push:tags:- &amp;#34;v[0-9]+.[0-9]+.[0-9]+&amp;#34;jobs:goreleaser:runs-on:ubuntu-lateststeps:- name:Checkoutuses:actions/checkout@v1with:fetch-depth:1- name:Setup Gouses:actions/setup-go@v1with:go-version:1.13- name:Run GoReleaseruses:goreleaser/goreleaser-action@v1with:version:latestargs:release --rm-distenv:GITHUB_TOKEN:${{ secrets.GITHUB_TOKEN }}つぎに .goreleaser.yml を置く。このファイルはツール名の部分だけリポジトリに沿うように変更する (git-bump のところ)。
project_name:git-bumpenv:- GO111MODULE=onbefore:hooks:- go mod tidybuilds:- main:.binary:git-bumpldflags:- -s -w- -X main.Version={{.Version}}- -X main.</description>
    </item>
    
    <item>
      <title>ローカルから Gist を編集する方法</title>
      <link>https://tellme.tokyo/post/2020/01/28/gist-in-local/</link>
      <pubDate>Tue, 28 Jan 2020 22:04:26 +0900</pubDate>
      
      <guid>https://tellme.tokyo/post/2020/01/28/gist-in-local/</guid>
      <description>コードスニペットなどの管理によく Gist を使う。 他にも特定の人にテキストを共有する目的で日本語を書いて置いておく場としても利用している。
頻繁に読み書きするとなるとウェブから編集するのは少し手間に感じてくる。 構造化された文章を書くなら慣れたエディタで書きたい。 ローカルにコピペしてきてから編集してウェブ画面でペーストしていたこともあるが、頻繁にとなるとこれも結構面倒くさい。
Gist はあくまでも git リポジトリなので git clone して手元で編集して push することもできる。 かといってそれをやるかというとそれもまた面倒。 テキスト編集するだけなのに git fetch も git commit もしたくない。 なるべくそういったことは隠蔽されていてほしい。 どこに clone するかといったことは ghq を使うことで考えなくてよくなるけど根本的な面倒くささは拭えない。
こういったモチベーションからウェブから読み書きするのと同じ体験をローカルで再現するツールを書いた1。
gist という Gist に対して簡単な CRUD 操作ができるツールを Go で書いた。
 gistコマンドは次のサブコマンドを持つ。
   コマンド 説明     new 引数に渡されたファイルを Gist にアップロードする。引数がない場合は tmp ファイルを開き、エディタを閉じたらその内容でアップロードする   open 記事一覧を表示して選択されたファイルの Gist ページをブラウザで開く   edit 記事一覧を表示して選択されたファイルをエディタで開く   delete 記事一覧を表示して選択されたファイルの Gist ページを消す    これらのコマンドは実際に new とか edit する前に内部で次のことをする。</description>
    </item>
    
    <item>
      <title>Go でシェルの Exit code を扱う</title>
      <link>https://tellme.tokyo/post/2018/04/02/golang-shell-exit-code/</link>
      <pubDate>Mon, 02 Apr 2018 23:42:39 +0900</pubDate>
      
      <guid>https://tellme.tokyo/post/2018/04/02/golang-shell-exit-code/</guid>
      <description>CLI ツールはよく Go で書く。 (Go でなくとも) ちゃんとした CLI ツールを書こうとすると、Exit code とそのエラーの取り回しについて悩むことが多い。 今回は、何回か遭遇したこの悩みに対する現時点における自分的ベストプラクティスをまとめておく。
ToC
 Exit code とは Go における Exit code 高次での取り回し  CLI 側 処理側   まとめ  Exit code とは $ ./script/something.sh $ echo $? 0 $? で参照できる値で、0 は成功を表し、0 以外は失敗を含む別の意味を表す。取りうる範囲は 0 - 255 (シェルによって違うことがあるかも知れない)。
$ true $ echo $? 0 $ false $ echo $? 1 詳しくは、コマンドラインツールを書くなら知っておきたい Bash の 予約済み Exit Code - Qiita
CLI ツールとはいわゆる UNIX コマンドであることが多いので、その慣習にならって実装するのよい。 成功したら 0 を、失敗したらエラーメッセージとともに非 0 を返すといった感じ。</description>
    </item>
    
  </channel>
</rss>
