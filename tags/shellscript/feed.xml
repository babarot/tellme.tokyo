<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shellscript on tellme.tokyo</title>
    <link>https://tellme.tokyo/tags/shellscript/</link>
    <description>Recent content in shellscript on tellme.tokyo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>BABAROT All Right Reserved.</copyright>
    <lastBuildDate>Fri, 07 Feb 2020 12:27:21 +0900</lastBuildDate><atom:link href="https://tellme.tokyo/tags/shellscript/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>標準出力に出しつつ、パイプ先のコマンドにも繋ぐ</title>
      <link>https://tellme.tokyo/post/2020/02/07/tee-command/</link>
      <pubDate>Fri, 07 Feb 2020 12:27:21 +0900</pubDate>
      
      <guid>https://tellme.tokyo/post/2020/02/07/tee-command/</guid>
      <description>コマンドの結果を目で見ながら、パイプに渡すなどするときのこと。
よくやるのに忘れるのでメモする。
結論 some-command | tee &amp;gt;(pipe-command) 解説 tee コマンドを使うとできる。
肝は tee が input されたデータを、
 標準出力 リダイレクト先  これらに output することができるので、リダイレクト先をプロセス置換1を使ってパイプに渡したいコマンドを指定することで標準出力に出しつつ、特定のコマンドにパイプすることができる。
実際のデモ:
seq 15 | tee &amp;gt;(grep 4) tee は標準出力ではなく、標準エラー出力にも出すことができる。 普通に file descriptor 2番に出力する。
seq 15 | tee &amp;gt;(grep 4) &amp;gt;&amp;amp;2 # もしくは seq 15 | tee &amp;gt;&amp;amp;2 &amp;gt;(grep 4) よくやるシーンとして、CI のコンソールにも出しつつ、結果を GitHub コメントに POST する、といったときにやる。
notify() { local comment template comment=&amp;#34;$(tee &amp;gt;(cat)&amp;gt;&amp;amp;2)&amp;#34; # pipe and output stderr template=&amp;#34;## Some results \`\`\` %s \`\`\` &amp;#34; comment=&amp;#34;$(printf &amp;#34;${template}&amp;#34; &amp;#34;${comment}&amp;#34;)&amp;#34; github_comment &amp;#34;${comment}&amp;#34; } some_output_func | notify mercari/tfnotify も最初はこういう感じのシェルスクリプトから始まったことを思い出した。</description>
    </item>
    
    <item>
      <title>最近、httpstat なるものが流行っているらしい</title>
      <link>https://tellme.tokyo/post/2016/09/25/213810/</link>
      <pubDate>Sun, 25 Sep 2016 21:38:10 +0900</pubDate>
      
      <guid>https://tellme.tokyo/post/2016/09/25/213810/</guid>
      <description>おそらく先行実装は python で書かれたこれです。
 curl にはウェブサイトの応答時間を計測する機能が搭載されており、このツールではそれを利用して出力結果をグラフィカルに表示させています。単なる curl のラッパーのようなツールなのですが、見た目がリッチになるのに加えて、単一ファイルで実行でき python のバージョンに影響されないような工夫がされているのが、受けているポイントのような気がします。
このツールを見たとき「Go で書いてみるの良さそう！（この手のツールで単一バイナリになるのは嬉しいですよね）」と思い、休憩時間やお昼休みなどにちまちま書いていたら、二日前に先を越されてしまいました（そりゃそうですよね。なんでもスピードが大事だと痛感）。
  また、ついこの間まで 800 Stars くらいだったのですが、ここ1週間で爆発的に伸びています（記事投稿時 1,100 Stars）。 これを機になのか、色々な実装を見るようになりました（Go 実装は Library として）。知らないだけで他にもあるかもしれません。
 [https://github.com/yosuke-furukawa/httpstat] (JavaScript) [https://github.com/tcnksm/go-httpstat] (Go) [https://github.com/talhasch/php-httpstat] (PHP)  Go で先を越され少し悔しい気もするので、curl のラッパーだしシェルスクリプトでも書いてみようと思い、書いてみました。なんのメリットがあるかは分かりませんが、bash オンリーで書いているので bash のある環境であれば動くはずです。
 次に時間があるときは Vim script で書こうかな。</description>
    </item>
    
    <item>
      <title>HTTP のステータスコードを簡単に調べる</title>
      <link>https://tellme.tokyo/post/2015/11/07/165928/</link>
      <pubDate>Sat, 07 Nov 2015 16:59:28 +0900</pubDate>
      
      <guid>https://tellme.tokyo/post/2015/11/07/165928/</guid>
      <description>HTTPステータスコードは、HTTPにおいてWebサーバからのレスポンスの意味を表現する3桁の数字からなるコードで、RFC 2616、RFC 7231等によって定められている。via HTTPステータスコード - Wikipedia
 403とか404はよく目にもするので覚えていますが、300番台は？500番台は？とかとなると思い出せないことが多いです。いちいちググり直すのも手間。そんなときに、bash なりのシェルにてエイリアスとして登録しているハックを目にしました。
 Jxck/dotfiles - GitHub  このまま参考にさせてもらおう、と思ったのですがすべて登録するのもな、と思いコマンドで用意しました（番号が変わるものでもないので一度登録して変更することになる心配がないためエイリアスもいいと思います）。

 b4b4r07/http_code - GitHub  antigen で簡単にインストールできます。
$ antigen bundle b4b4r07/http_code antigen でない場合は、
sudo sh -c &amp;#34;curl https://raw.githubusercontent.com/b4b4r07/http_code/master/bin/http_code -o /usr/local/bin/http_code &amp;amp;&amp;amp; chmod +x /usr/local/bin/http_code&amp;#34; しかし、antigen でインストールしたほうが、補完ファイルなども使用できるようになります。
使い方は gif アニメにもある通り、-a/--all オプションをつけると一覧表示、引数に数字を渡すとそれに対する説明を返します。</description>
    </item>
    
  </channel>
</rss>
